// Generated by CoffeeScript 1.3.3
(function() {
  var RESERVED, coffeescript, contains, fs, isString, mb, path, runInExecDir, wrench, _base, _ref;

  isString = function(obj) {
    return Object.prototype.toString.call(obj) === '[object String]';
  };

  contains = function(array, value) {
    var test, _i, _len;
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      test = array[_i];
      if (test === value) {
        return true;
      }
    }
    return false;
  };

  fs = require('fs');

  path = require('path');

  wrench = require('wrench');

  coffeescript = require('coffee-script');

  mb = this.mb = typeof exports !== 'undefined' ? exports : {};

  RESERVED = ['_publish', '_load', '_alias'];

  if ((_ref = (_base = require.extensions)['.coffee']) == null) {
    _base['.coffee'] = function(module, filename) {
      var content;
      content = coffeescript.compile(fs.readFileSync(filename, 'utf8', {
        filename: filename
      }));
      return module._compile(content, filename);
    };
  }

  mb.writeBundleSync = function(filename, config, options) {
    var bundle_code, directory, resolved_filename;
    if (!filename) {
      throw 'module-bundler: missing output filename or object';
    }
    if (!config) {
      throw 'module-bundler: missing config object';
    }
    if (!(options && options.cwd)) {
      throw 'module-bundler: missing options.cwd';
    }
    bundle_code = mb.generateBundleCode(config, options);
    if (!bundle_code) {
      return false;
    }
    resolved_filename = mb.resolveSafe(filename, options);
    try {
      directory = path.dirname(resolved_filename);
      if (!path.existsSync(directory)) {
        wrench.mkdirSyncRecursive(directory, 0x1ff);
      }
    } catch (e) {
      if (e.code !== 'EEXIST') {
        throw e;
      }
    }
    fs.writeFileSync(resolved_filename, "(function() {\n" + bundle_code + "})(this);\n", 'utf8');
    return true;
  };

  mb.writeBundlesSync = function(config, options) {
    var bundle_config, filename, success;
    if (!config) {
      throw 'module-bundler: missing config filename or object';
    }
    if (!(options && options.cwd)) {
      throw 'module-bundler: missing options.cwd';
    }
    if (isString(config)) {
      try {
        config = require(mb.resolveSafe(config, options));
      } catch (e) {
        console.log(e.message);
        return;
      }
    }
    success = true;
    for (filename in config) {
      bundle_config = config[filename];
      success &= mb.writeBundleSync(filename, bundle_config, options);
    }
    return success;
  };

  runInExecDir = function(fn, cwd) {
    var original_dirname, result;
    if (cwd) {
      original_dirname = fs.realpathSync('.');
      process.chdir(cwd);
      result = fn();
      return process.chdir(original_dirname);
    } else {
      return fn();
    }
  };

  mb.pathNormalizeSafe = function(target, options) {
    var cwd, normalized_target;
    if (options == null) {
      options = {};
    }
    if (options.cwd) {
      cwd = path.normalize(options.cwd);
    }
    if (target.substr(0, process.env.HOME.length) === process.env.HOME) {
      return target;
    }
    if (cwd && (target.substr(0, cwd.length) === cwd)) {
      return target;
    }
    normalized_target = target;
    runInExecDir((function() {
      try {
        return normalized_target = path.normalize(target);
      } catch (e) {

      }
    }), cwd);
    return normalized_target;
  };

  mb.requireResolveSafe = function(target, options) {
    var cwd, resolved_target;
    if (options == null) {
      options = {};
    }
    if (options.cwd) {
      cwd = path.normalize(options.cwd);
    }
    if (target.substr(0, process.env.HOME.length) === process.env.HOME) {
      return target;
    }
    if (cwd && (target.substr(0, cwd.length) === cwd)) {
      return target;
    }
    resolved_target = target;
    runInExecDir((function() {
      try {
        return resolved_target = require.resolve(target);
      } catch (e) {

      }
    }), cwd);
    return resolved_target;
  };

  mb.resolveSafe = function(target, options) {
    var char, cwd, is_file, next_char, path_to_target, raw_target, _i, _len;
    if (options == null) {
      options = {};
    }
    if (options.cwd) {
      cwd = path.normalize(options.cwd);
    }
    is_file = target.search(/^file:\/\//) >= 0;
    if (is_file) {
      target = target.replace(/^file:\/\//, '');
    }
    if (!(options.skip_require || is_file)) {
      target = mb.requireResolveSafe(target, options);
    }
    if (target.substr(0, process.env.HOME.length) === process.env.HOME) {
      return target;
    }
    if (cwd && (target.substr(0, cwd.length) === cwd)) {
      return target;
    }
    if (target[0] === '.') {
      for (_i = 0, _len = target.length; _i < _len; _i++) {
        char = target[_i];
        next_char = char;
        if (char !== '.' && char !== '/') {
          break;
        }
      }
      if (next_char === '.' || '/') {
        raw_target = path.join((cwd ? cwd : cwd), target);
      } else {
        raw_target = path.join(cwd, target);
      }
    } else if (target[0] === '~') {
      raw_target = target.replace(/^~/, process.env.HOME);
    } else if (cwd) {
      raw_target = path.join(cwd, target);
    } else {
      raw_target = target;
    }
    path_to_target = path.normalize(raw_target);
    if (options.must_exist && !path.existsSync(path_to_target)) {
      return '';
    }
    return path_to_target;
  };

  mb.generateLibraryCode = function() {
    return "var root = this;\nvar root_require = root.require;\nvar root_require_define = root_require ? root.require.define : null;\nvar root_require_resolve = root_require ? root.require.resolve : null;\n\n/*\nDefine module-bundler require functions\n*/\nvar mb = (typeof(exports) !== 'undefined') ? exports : {};\nmb.modules = {};\nmb.require = function(module_name) {\n  if (!mb.modules.hasOwnProperty(module_name)) {\n    if (root_require) {\n      return root_require.apply(this, arguments);\n    }\n    throw \"Cannot find module '\" + module_name + \"'\";\n  }\n  if (!mb.modules[module_name].exports) {\n    mb.modules[module_name].exports = {};\n    mb.modules[module_name].loader.call(root, mb.modules[module_name].exports, mb.require, mb.modules[module_name]);\n  }\n  return mb.modules[module_name].exports;\n};\nmb.require_define = function(obj) {\n  for (var module_name in obj) {\n    mb.modules[module_name] = {loader: obj[module_name]};\n  }\n};\nmb.require_alias = function(alias_name, module_name) {\n  mb.modules[alias_name] = {exports: root.require(module_name)};\n};\nmb.require_resolve = function(module_name) {\n  if (!mb.modules[module_name]) {\n    if (root_require_resolve) {\n      return root_require_resolve.apply(this, arguments);\n    }\n    throw \"Cannot find module '\" + module_name + \"'\"\n  }\n  return module_name;\n};\n\n// overwrite the root implementation\nroot.require = mb.require;\nif (root_require) {\n  // copy all additional properties\n  for (var key in root_require)\n    root.require[key] = root_require[key];\n}\nroot.require.resolve = mb.require_resolve;\n";
  };

  mb.generateAliasCode = function(entries) {
    var alias_name, code, module_name;
    code = "\n";
    for (alias_name in entries) {
      module_name = entries[alias_name];
      code += "mb.require_alias('" + alias_name + "', '" + module_name + "');\n";
    }
    return code;
  };

  mb.generatePublishCode = function(entries) {
    var code, module_name, symbol;
    code = "\n";
    for (symbol in entries) {
      module_name = entries[symbol];
      code += "root['" + symbol + "'] = root.require('" + module_name + "');\n";
    }
    return code;
  };

  mb.generateLoadCode = function(entries) {
    var code, module_name, _i, _len;
    code = "\n";
    if (isString(entries)) {
      entries = [entries];
    }
    for (_i = 0, _len = entries.length; _i < _len; _i++) {
      module_name = entries[_i];
      code += "root.require('" + module_name + "');\n";
    }
    return code;
  };

  mb.generateModuleCode = function(module_name, filename, options) {
    var file_contents, pathed_file;
    if (contains(RESERVED, module_name)) {
      throw "module name cannot be a reservered word: " + module_name;
    }
    pathed_file = mb.resolveSafe(filename, options);
    try {
      file_contents = fs.readFileSync(pathed_file, 'utf8');
    } catch (e) {
      console.log("Couldn't bundle '" + filename + "'. Does it exist?");
      return;
    }
    return "\nmb.require_define({'" + module_name + "': function(exports, require, module) {\n\n" + file_contents + "\n}});\n";
  };

  mb.generateBundleCode = function(config, options) {
    var code, key, module_code, success, value;
    code = mb.generateLibraryCode();
    success = true;
    for (key in config) {
      value = config[key];
      if (contains(RESERVED, key)) {
        continue;
      }
      module_code = mb.generateModuleCode(key, value, options);
      if (module_code) {
        code += module_code;
      } else {
        success = false;
      }
    }
    if (config.hasOwnProperty('_alias')) {
      code += mb.generateAliasCode(config._alias);
    }
    if (config.hasOwnProperty('_publish')) {
      code += mb.generatePublishCode(config._publish);
    }
    if (config.hasOwnProperty('_load')) {
      code += mb.generateLoadCode(config._load);
    }
    if (success) {
      return code;
    } else {

    }
  };

}).call(this);
